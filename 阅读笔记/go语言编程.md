## go的内置函数
Golang设计者为了编程方便，提供了一些函数，这些函数不用导包可以直接使用，我们称为Go的内置函数或内建函数。例如`len()`函数、`new()`函数。

## go函数的默认参数
在使用Go语言写函数时，不能像Python一样设置函数的默认参数，有时候，不能设置默认参数让我们处理起来有点麻烦，特别是有时候函数的参数想让使用者自己决定的时候，不禁让人感叹Python的方便。

## go匿名函数
在Go语言中，所有的函数也是值类型，可以作为参数传递。

## go接口
接口的抽象水平和类是同级的，接口是类的泛化。接口和类之间的关系可以类比机动车与家用轿车之间的关系，只要实现了“由自带动力装置驱动或牵引，可在陆地上行驶的轮式交通工具”功能的都可以叫做机动车，所有家用轿车的实例自然而然也是机动车的实例。
在放弃了大量的OOP特性后， Go语言送上了一份非常棒的礼物：接口（interface） 。你可能会说，除了C这么原始的语言外，还有什么语言没有接口呢？是的，多数语言都提供接口，但它们的接口都不同于Go语言的接口。Go语言中的接口与其他语言最大的一点区别是它的非侵入性。
与其他语言不同，在Go语言中，实现类的时候无需从接口派生，不需要显式地声明类与接口的继承关系，具体代码如下：
```go
type Foo struct { // Go 文法
    ...
}
var foo IFoo = new(Foo)
```
只要Foo实现了接口IFoo要求的所有方法，就实现了该接口，可以进行赋值。虽然类型实现的时候，没有声明与接口的关系，但接口和类型可以直接转换，甚至接口的定义都不用在类型定义之前，这种比较松散的对应关系可以大幅降低因为接口调整而导致的大量代码调整工作。

## go反射
Go语言的反射实现了反射的大部分功能，但没有像Java语言那样内置类型工厂，故而无法做到像Java那样通过类型字符串创建对象实例。在Java中，你可以读取配置并根据类型名称创建对应的类型，这是一种常见的编程手法，但在Go语言中这并不被推荐。

## go函数
Go支持多个返回值。并不是所有返回值都必须赋值。在函数返回时没有被明确赋值的返回值都会被设置为默认值，比如result会被设为0.0， err会被设为nil。

### delete函数
delete函数是Go的内置函数，它按照指定的键将元素从map中删除。若要删除的键为 nil 或在map中不存在，delete 不进行任何操作。类似于python中dict对象的pop方法。

## 变量
Go语言的变量声明方式与C和C++语言有明显的不同。对于纯粹的变量声明， Go语言引入了关键字var，而类型信息放在变量名之后，示例如下：
```golang
var v1 int
var v2 string
var v3 [10]int // 数组
var v4 []int // 数组切片
var v5 struct {
    f int
}
var v6 *int // 指针
var v7 map[string]int // map， key为string类型， value为int类型
var v8 func(a int) int
```
变量声明语句不需要使用分号作为结束符。与C语言相比， Go语言摒弃了语句必须以分号作为语句结束标记的习惯，这点与python是一致的。
var关键字的另一种用法是可以将若干个需要声明的变量放置在一起，免得程序员需要重复写var关键字，如下所示：
```golang
var (
    v1 int
    v2 string
)
```
对于声明变量时需要进行初始化的场景， var关键字可以保留，但不再是必要的元素，如下所示：
```golang
var v1 int = 10 // 正确的使用方式1
var v2 = 10 // 正确的使用方式2，编译器可以自动推导出v2的类型
v3 := 10 // 正确的使用方式3，编译器可以自动推导出v3的类型
```
指定类型已不再是必需的， Go编译器可以从初始化表达式的右值推导出该变量应该声明为哪种类型，这让Go语言看起来有点像动态类型语言，尽管Go语言实际上是不折不扣的强类型语言（静态类型语言）。
### 变量赋值
Go语言的变量赋值与多数语言一致，但Go语言中提供了C/C++程序员期盼多年的多重赋值功能，比如下面这个交换i和j变量的语句：
```golang
i, j = j, i
```
多重赋值功能让Go语言与C/C++语言相比可以非常明显地减少代码行数。在这方面，go的设计与python是一致的。
### 匿名变量
我们在使用传统的强类型语言编程时，经常会出现这种情况，即在调用函数时为了获取一个值，却因为该函数返回多个值而不得不定义一堆没用的变量。在Go中这种情况可以通过结合使用多重返回和匿名变量来避免这种丑陋的写法，让代码看起来更加优雅。假设 `GetName()` 函数的定义如下，它返回3个值，分别为firstName、lastName和nickName：
```go
func GetName() (firstName, lastName, nickName string) {
    return "May", "Chan", "Chibi Maruko"
}
```
若只想获得nickName，则函数调用语句可以用如下方式编写：
```go
_, _, nickName := GetName()
```
这种用法可以让代码非常清晰，基本上屏蔽掉了可能混淆代码阅读者视线的内容，从而大幅降低沟通的复杂度和代码维护的难度。python语言中也支持类似的用法。
## 常量
通过const关键字，你可以给字面常量指定一个友好的名字：
```go
const Pi float64 = 3.14159265358979323846
const zero = 0.0 // 无类型浮点常量
const (
    size int64 = 1024
    eof = -1 // 无类型整型常量
)
const u, v float32 = 0, 3 // u = 0.0, v = 3.0，常量的多重赋值
const a, b, c = 3, 4, "foo"
// a = 3, b = 4, c = "foo", 无类型整型和字符串常量
```
Go的常量定义可以限定常量类型，但不是必需的。如果定义常量时没有指定类型，那么它与字面常量一样，是无类型常量。
由于常量的赋值是一个编译期行为，所以右值不能出现任何需要运行期才能得出结果的表达式，比如试图以如下方式定义常量就会导致编译错误：
```go
const Home = os.GetEnv("HOME")
```
原因很简单，`os.GetEnv()`只有在运行期才能知道返回结果，在编译期并不能确定，所以无法作为常量定义的右值。
### 枚举
枚举指一系列相关的常量，比如下面关于一个星期中每天的定义。通过上一节的例子，我们看到可以用在`const`后跟一对圆括号的方式定义一组常量，这种定义法在Go语言中通常用于定义枚举值。 Go语言并不支持众多其他语言明确支持的`enum`关键字。
下面是一个常规的枚举表示法，其中定义了一系列整型常量：
```go
const (
    Sunday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    numberOfDays // 这个常量没有导出
)
```
同Go语言的其他符号（symbol）一样，以大写字母开头的常量在包外可见。以上例子中`numberOfDays`为包内私有，其他符号则可被其他包访问。

## 多线程
并发是编程里面一个非常重要的概念。

> 一颗cpu相当于一把锤头，进程和线程是cpu的用户，相当于铁匠铺和铁匠，一个铁匠铺里至少有一位铁匠，每个进程也至少包含一个线程，一个任务可以对应于铸一把剑。

现在让我们理解多线程里的一些概念。我们假设每个铁匠一个月只能铸造1把宝剑。一个铁匠一个月工资1两银子，一把锤头100两银子。

并发：同一时间段内执行多个任务，对应于一个月内铸造10把宝剑，并发数就是10。
并行：同一时刻执行多个任务，对应于同一时刻10个铁匠打铁铸剑，因此要求有10把锤头，也就是10核心。

可以看出，两种技术都能提高产能，但是两种技术切入的角度不同。

我们首先看一下并行技术给我们带来了什么。有10位剑客，在铁匠铺没有采用并行技术之前，需要10个月才能交付所有的宝剑，采用并行技术，铁匠铺升级了设备，在1个月之内交付了货物，产能提高10倍。
假设我们没有并行，我们有1个铁匠（单线程），1把锤头（单核心），不管铁匠铺如何编排铸剑的各项流程，如何压榨我们的铁匠，交付时间都不可能少于10个月。那我们如何在一个月内完成这个铸造10把宝剑的大单？锤头是很贵的，我们的铁匠铺老板不愿意增加在设备上的投入，但铁匠的人力比较便宜。最容易想到的办法是雇佣10个铁匠，通过巧妙的排列使铁匠交错地使用锤头。通过巧妙的编排实现共享一把锤头，我们的铁匠铺一个月也铸造了10把宝剑。我们通过并发技术也提高了我们的产能10倍。

显然，并发技术侧重于资源利用率的提升，而并行技术侧重于增加资源。并行是土豪的解决办法，并发就像是抠门的资本家。需要注意的是，并发对产能的提高是有极限的，如果达到并发极限还是不能满足需求，就必须考虑并行，也就是堆积硬件，或者重新设计硬件。

并发和并行有很多种实现方式，每种编程语言对这些实现方式的支持情况也不一样。

### 其他语言
对于java语言来说，创建线程和销毁线程的花销是比较大的（手动new Thread 类），创建和消耗线程的时间有可能比处理业务的时间还要长。这样频繁的创建线程和销毁线程是比较消耗资源的。（我们可以把创建和销毁的线程的过程去掉）。而goroutine解决了这个问题。
在 C++/Java 实现线程池时，通常可能为了解决创建取消线程开销过大的问题，同时也为不同优先级的请求提供不同的调度模式。
Go语言包中的 sync 包提供了两种锁类型：sync.Mutex 和 sync.RWMutex。
Mutex 是最简单的一种锁类型，同时也比较暴力，当一个 goroutine 获得了 Mutex 后，其他 goroutine 就只能乖乖等到这个 goroutine 释放该 Mutex。
这与python中的多线程类似。GIL是Cpython中的全局锁，也就是一个进程中只有一个，没有拿到GIL就不允许在CPU中执行，由于python全局解释器锁GIL的存在，python中的多线程并不能充分利用多核CPU。Python在多进程下没有什么问题，但是在多线程下问题就出来了。Python的多线程在处理CPU密集型任务时并不是很友好，解决的办法就是使用多进程+协程的方式。Python的线程会在遇到IO操作时释放GIL，执行别的线程， 所以Python多线程对IO密集型任务比较友好。
RWMutex 相对友好些，是经典的单写多读模型。在读锁占用的情况下，会阻止写，但不阻止读，也就是多个 goroutine 可同时获取读锁（调用 RLock() 方法；而写锁（调用 Lock() 方法）会阻止任何其他 goroutine（无论读和写）进来，整个锁相当于由该 goroutine 独占。
Goroutines 以及基于通道的并发性方法使其非常容易使用所有可用的 CPU 内核，并处理并发的 IO。相较于 Python/Java，在一个 goroutine 上运行一个函数需要最小的代码。
### go语言
其他语言一般都通过第三方包构造线程池支持并发，Go语言在语言层面天生支持并发。
Go语言的并发通过 goroutine 实现，goroutine 类似线程，属于用户态的线程，我们可以根据需要创建成千上万个 goroutine 并发工作。goroutine 是由Go语言的运行时(runtime)调度完成，二线程是由操作系统调度完成。
#### goroutine
在编写 Socket 网络程序时，需要提前准备一个线程池为每一个 Socket 的收发包分配一个线程。开发人员需要在线程数量和 CPU 数量间建立一个对应关系，以保证每个任务能及时地被分配到 CPU 上进行处理，同时避免多个任务频繁地在线程间切换执行而损失效率。
虽然，线程池为逻辑编写者提供了线程分配的抽象机制。但是，如果面对随时随地可能发生的并发和线程处理需求，线程池就不是非常直观和方便了。能否有一种机制：使用者分配足够多的任务，系统能自动帮助使用者把任务分配到 CPU 上，让这些任务尽量并发运作。这种机制在 Go语言中被称为 goroutine。
goroutine 是 Go语言中的轻量级线程实现，由 Go 运行时（runtime）管理。Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。

终止 goroutine 的最好方法就是自然返回 goroutine 对应的函数。虽然可以用 golang.org/x/net/context 包进行 goroutine 生命期深度控制，但这种方法仍然处于内部试验阶段，并不是官方推荐的特性。

截止 Go 1.9 版本，暂时没有标准接口获取 goroutine 的 ID。

#### work pool (goroutine 池子)
goroutine 的工作模式：在工作中我们通常会使用可以指定启动的goroutine数量worker pool模式，控制goroutine的数量，防止goroutine泄漏和暴涨。例如：

```golang
package main

import (
	"fmt"
	"time"
)

// work_pool
func worker(id int,jobs<-chan int,res chan<- int){
	for job := range jobs{
		fmt.Printf("worker:%d job:%d\n",id,job)
		res <- job*2
		time.Sleep(time.Millisecond*500)
		fmt.Printf("worker:%d job:%d\n",id,job)
	}

}
func main() {
	jobs :=make(chan int,100)
	res := make(chan int,100)

	// 开启3个goroutine
	for j:=0;j<3;j++{
		go worker(j,jobs,res)
	}
    // channel中无值，range时，会阻塞下边语句执行，阻塞到channel关闭，再接着执行下边的语句
    // 虽然目前jobs是空的，但worker不会range完退出，而是会一直等待jobs关闭。

	// 发送5个任务
	for i:=0;i<5;i++{
		jobs <- i
	}
	close(jobs)
    // 关闭jobs以后，worker接着执行下面的逻辑，结束goroutine
	
    //输出结果
	for i:=0;i<5;i++{
		ret := <-res
		fmt.Println(ret)
	}
}
```
读取channel中的值时，若channel中无值，会阻塞后边的语句，那么通过range读取channel中的值，何时会跳出range接着执行？
结论：1.channel的关闭时机：1）给channel调用close()且其中数据全部被消费结束。2）主线程关闭

## 接口
不关注具体实现的都叫接口。例如rest接口。

我们看下百度是怎么给出API的定义的：
> API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。



