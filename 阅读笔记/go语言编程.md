## go的内置函数
Golang设计者为了编程方便，提供了一些函数，这些函数不用导包可以直接使用，我们称为Go的内置函数或内建函数。例如`len()`函数、`new()`函数。

## go函数的默认参数
在使用Go语言写函数时，不能像Python一样设置函数的默认参数，有时候，不能设置默认参数让我们处理起来有点麻烦，特别是有时候函数的参数想让使用者自己决定的时候，不禁让人感叹Python的方便。

## go匿名函数
在Go语言中，所有的函数也是值类型，可以作为参数传递。

## go接口
接口的抽象水平和类是同级的，接口是类的泛化。接口和类之间的关系可以类比机动车与家用轿车之间的关系，只要实现了“由自带动力装置驱动或牵引，可在陆地上行驶的轮式交通工具”功能的都可以叫做机动车，所有家用轿车的实例自然而然也是机动车的实例。
在放弃了大量的OOP特性后， Go语言送上了一份非常棒的礼物：接口（interface） 。你可能会说，除了C这么原始的语言外，还有什么语言没有接口呢？是的，多数语言都提供接口，但它们的接口都不同于Go语言的接口。Go语言中的接口与其他语言最大的一点区别是它的非侵入性。
与其他语言不同，在Go语言中，实现类的时候无需从接口派生，不需要显式地声明类与接口的继承关系，具体代码如下：
```go
type Foo struct { // Go 文法
    ...
}
var foo IFoo = new(Foo)
```
只要Foo实现了接口IFoo要求的所有方法，就实现了该接口，可以进行赋值。虽然类型实现的时候，没有声明与接口的关系，但接口和类型可以直接转换，甚至接口的定义都不用在类型定义之前，这种比较松散的对应关系可以大幅降低因为接口调整而导致的大量代码调整工作。

## go反射
Go语言的反射实现了反射的大部分功能，但没有像Java语言那样内置类型工厂，故而无法做到像Java那样通过类型字符串创建对象实例。在Java中，你可以读取配置并根据类型名称创建对应的类型，这是一种常见的编程手法，但在Go语言中这并不被推荐。

## go函数
Go支持多个返回值。并不是所有返回值都必须赋值。在函数返回时没有被明确赋值的返回值都会被设置为默认值，比如result会被设为0.0， err会被设为nil。

## 变量
Go语言的变量声明方式与C和C++语言有明显的不同。对于纯粹的变量声明， Go语言引入了关键字var，而类型信息放在变量名之后，示例如下：
```golang
var v1 int
var v2 string
var v3 [10]int // 数组
var v4 []int // 数组切片
var v5 struct {
    f int
}
var v6 *int // 指针
var v7 map[string]int // map， key为string类型， value为int类型
var v8 func(a int) int
```
变量声明语句不需要使用分号作为结束符。与C语言相比， Go语言摒弃了语句必须以分号作为语句结束标记的习惯，这点与python是一致的。
var关键字的另一种用法是可以将若干个需要声明的变量放置在一起，免得程序员需要重复写var关键字，如下所示：
```golang
var (
    v1 int
    v2 string
)
```
对于声明变量时需要进行初始化的场景， var关键字可以保留，但不再是必要的元素，如下所示：
```golang
var v1 int = 10 // 正确的使用方式1
var v2 = 10 // 正确的使用方式2，编译器可以自动推导出v2的类型
v3 := 10 // 正确的使用方式3，编译器可以自动推导出v3的类型
```
指定类型已不再是必需的， Go编译器可以从初始化表达式的右值推导出该变量应该声明为哪种类型，这让Go语言看起来有点像动态类型语言，尽管Go语言实际上是不折不扣的强类型语言（静态类型语言）。
### 变量赋值
Go语言的变量赋值与多数语言一致，但Go语言中提供了C/C++程序员期盼多年的多重赋值功能，比如下面这个交换i和j变量的语句：
```golang
i, j = j, i
```
多重赋值功能让Go语言与C/C++语言相比可以非常明显地减少代码行数。在这方面，go的设计与python是一致的。
### 匿名变量
我们在使用传统的强类型语言编程时，经常会出现这种情况，即在调用函数时为了获取一个值，却因为该函数返回多个值而不得不定义一堆没用的变量。在Go中这种情况可以通过结合使用多重返回和匿名变量来避免这种丑陋的写法，让代码看起来更加优雅。假设 `GetName()` 函数的定义如下，它返回3个值，分别为firstName、lastName和nickName：
```go
func GetName() (firstName, lastName, nickName string) {
    return "May", "Chan", "Chibi Maruko"
}
```
若只想获得nickName，则函数调用语句可以用如下方式编写：
```go
_, _, nickName := GetName()
```
这种用法可以让代码非常清晰，基本上屏蔽掉了可能混淆代码阅读者视线的内容，从而大幅降低沟通的复杂度和代码维护的难度。python语言中也支持类似的用法。
## 常量
通过const关键字，你可以给字面常量指定一个友好的名字：
```go
const Pi float64 = 3.14159265358979323846
const zero = 0.0 // 无类型浮点常量
const (
    size int64 = 1024
    eof = -1 // 无类型整型常量
)
const u, v float32 = 0, 3 // u = 0.0, v = 3.0，常量的多重赋值
const a, b, c = 3, 4, "foo"
// a = 3, b = 4, c = "foo", 无类型整型和字符串常量
```
Go的常量定义可以限定常量类型，但不是必需的。如果定义常量时没有指定类型，那么它与字面常量一样，是无类型常量。
由于常量的赋值是一个编译期行为，所以右值不能出现任何需要运行期才能得出结果的表达式，比如试图以如下方式定义常量就会导致编译错误：
```go
const Home = os.GetEnv("HOME")
```
原因很简单，`os.GetEnv()`只有在运行期才能知道返回结果，在编译期并不能确定，所以无法作为常量定义的右值。
### 枚举
枚举指一系列相关的常量，比如下面关于一个星期中每天的定义。通过上一节的例子，我们看到可以用在`const`后跟一对圆括号的方式定义一组常量，这种定义法在Go语言中通常用于定义枚举值。 Go语言并不支持众多其他语言明确支持的`enum`关键字。
下面是一个常规的枚举表示法，其中定义了一系列整型常量：
```go
const (
    Sunday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
    numberOfDays // 这个常量没有导出
)
```
同Go语言的其他符号（symbol）一样，以大写字母开头的常量在包外可见。以上例子中`numberOfDays`为包内私有，其他符号则可被其他包访问。
